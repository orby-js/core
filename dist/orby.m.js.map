{"version":3,"file":"orby.m.js","sources":["../src/vdom.js","../src/dom.js","../src/diff.js"],"sourcesContent":["export class VDom {\r\n    /**\r\n     *\r\n     * @param {Function|String} tag - Node component or label\r\n     * @param {Object} props - Properties of the label\r\n     * @param {Array} children - Children assigned to the node\r\n     */\r\n    constructor(tag, props = {}, children = []) {\r\n        this.tag = tag;\r\n        this.props = {\r\n            ...props,\r\n            children\r\n        };\r\n    }\r\n    /**\r\n     * Clone the current node by keeping props and children by default\r\n     * @param {Function|String} tag -  Node component or label\r\n     * @param {*} props - Properties of the label\r\n     * @param {*} children - Children assigned to the node\r\n     */\r\n    clone(tag = this.tag, props = this.props, children = this.props.children) {\r\n        return new VDom(tag, props, children);\r\n    }\r\n    /**\r\n     * Dispatch an existing function in `this.props`\r\n     * @param {String} prop - Property to emit the virtual node only if it exists as a function\r\n     * @param  {...any} args - Arguments to be issued to the function\r\n     */\r\n    emit(prop, ...args) {\r\n        if (this.prevent) return;\r\n        if (prop === \"remove\") this.prevent = true;\r\n        if (typeof this.props[prop] === \"function\") this.props[prop](...args);\r\n    }\r\n}\r\n/**\r\n * Prepare the virtual node\r\n * @param {Function|String} tag\r\n * @param {Object} props\r\n * @param  {...any} children\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag || \"\", props, concat(children));\r\n}\r\n/**\r\n * Verify if this is a virtual node\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * Clean existing values in virtual-dom tree\r\n * @param {*} children\r\n * @param {*} merge\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child) ? child : new VDom(\"\", {}, [child || \"\"])\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","export function create(tag, isSvg) {\r\n    return isSvg\r\n        ? document.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n        : tag\r\n        ? document.createElement(tag)\r\n        : document.createTextNode(\"\");\r\n}\r\n\r\nexport function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child, useShadowRoot) {\r\n    parent.removeChild(child);\r\n}\r\n\r\nexport function append(parent, child, useShadowRoot) {\r\n    parent.appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild, useShadowRoot) {\r\n    parent.replaceChild(newChild, oldChild);\r\n}\r\n","import { VDom, isVDom } from \"./vdom\";\r\nimport { create, remove, append, replace, root } from \"./dom\";\r\nexport { h, isVDom } from \"./vdom\";\r\n\r\nlet attachShadow = \"attachShadow\";\r\n\r\nexport let options = {\r\n    delay: 1\r\n};\r\n/**\r\n * Master is the mark to store the previous state\r\n * and if the node is controlled by one or more components\r\n */\r\nexport let MASTER = \"__master__\";\r\n/**\r\n * Each time a component is removed from the dom,\r\n * the property is marked as true\r\n */\r\nexport let REMOVE = \"__remove__\";\r\n\r\nexport let LISTENER = \"__listeners__\";\r\n/**\r\n * Special properties of virtual dom,\r\n * these are ignored from the diffProps process,\r\n * since it is part of the component's life cycle\r\n */\r\nexport let IGNORE = [\r\n    \"children\",\r\n    \"create\",\r\n    \"created\",\r\n    \"remove\",\r\n    \"removed\",\r\n    \"update\",\r\n    /**\r\n     * It is executed once sent to the diff process to the succesors\r\n     */\r\n    \"updated\",\r\n    /**\r\n     * Create a new context for successors\r\n     */\r\n    \"context\",\r\n    /**\r\n     * Defines the initial state for a component\r\n     */\r\n    \"state\",\r\n    /**\r\n     * It allows to avoid the execution of the\r\n     * component the same type of label that\r\n     * its predecessor is conserved\r\n     */\r\n    \"static\"\r\n];\r\n/**\r\n * It allows to print the status of virtual dom on the planned configuration\r\n * @param {VDom} next - the next state of the node\r\n * @param {HTMLElement} parent - the container of the node\r\n * @param {HTMLElement} [child]  - the ancestor of the node\r\n * @param {Object} [context] - the context of the node\r\n * @param {boolean} [isSvg] - check if the node belongs to a svg unit, to control it as such\r\n * @returns {HTMLElement} - The current node\r\n */\r\nexport function render(next, parent, child, context, isSvg) {\r\n    return diff(root(parent), child, next, context, isSvg);\r\n}\r\n/**\r\n * Gets the node's status mark\r\n * @param {HTMLElement} [base]\r\n * @return {object} - returns an object since the property associated\r\n *                    with the master in the whole diff is decomposed\r\n */\r\nexport function getMaster(base) {\r\n    return (base && base[MASTER]) || {};\r\n}\r\nexport function defer(handler) {\r\n    setTimeout(handler, options.delay);\r\n}\r\n/**\r\n *\r\n * @param {Function} component  - Function that controls the node\r\n * @param {*} [currentState] - The initial state of the component\r\n * @param {Boolean} [isSvg] - Create components for a group of svg\r\n * @return {HTMLElement} - Returns the current component node\r\n */\r\nexport function Component(tag, state, isSvg, deep, key, components) {\r\n    this.tag = tag;\r\n    this.state = state;\r\n    this.context = {};\r\n    this.prevent = false;\r\n    this.render = (parent, base) => {\r\n        let set = state => {\r\n                this.state = state;\r\n                if (!base[REMOVE] && !this.prevent) {\r\n                    this.prevent = true;\r\n                    defer(() => {\r\n                        this.render(parent, base);\r\n                        this.prevent = false;\r\n                    });\r\n                }\r\n            },\r\n            get = () => this.state;\r\n        return (base = diff(\r\n            parent,\r\n            base,\r\n            this.tag(this.props, { set, get }, this.context),\r\n            this.context,\r\n            isSvg,\r\n            deep + 1,\r\n            key + 1,\r\n            components\r\n        ));\r\n    };\r\n}\r\n/**\r\n * It allows to print the status of virtual dom on the planned configuration\r\n * @param {HTMLElement} parent - the container of the node\r\n * @param {HTMLElement} [node]  - the ancestor of the node\r\n * @param {VDom} next - the next state of the node\r\n * @param {Object} [context] - the context of the node\r\n * @param {boolean} [isSvg] - check if the node belongs to a svg unit, to control it as such\r\n * @returns {HTMLElement} - The current node\r\n */\r\n\r\nexport function diff(\r\n    parent,\r\n    node,\r\n    next,\r\n    context = {},\r\n    isSvg,\r\n    deep = 0,\r\n    currentKey = 0,\r\n    currentComponents = {}\r\n) {\r\n    next = isVDom(next) ? next : new VDom(\"\", {}, [next || \"\"]);\r\n\r\n    let base = node,\r\n        { prev = new VDom(), components = currentComponents } = getMaster(base),\r\n        component,\r\n        isCreate,\r\n        addContext = next.props.context;\r\n\r\n    context = addContext ? { ...context, ...addContext } : context;\r\n\r\n    isSvg = next.tag === \"svg\" || isSvg;\r\n    if (prev === next || (prev.tag && next.tag && next.props.static))\r\n        return base;\r\n\r\n    if (components[currentKey] && components[currentKey].tag !== next.tag) {\r\n        delete components[currentKey];\r\n    }\r\n\r\n    if (typeof next.tag === \"function\") {\r\n        if ((components[currentKey] || {}).tag !== next.tag) {\r\n            components[currentKey] = new Component(\r\n                next.tag,\r\n                next.props.state,\r\n                isSvg,\r\n                deep,\r\n                currentKey,\r\n                components\r\n            );\r\n        }\r\n        component = components[currentKey];\r\n        next = next.clone(prev.tag || (isSvg ? \"g\" : \"\"));\r\n    }\r\n\r\n    let children = next.props.children;\r\n\r\n    if (next.tag !== prev.tag) {\r\n        base = create(next.tag, isSvg);\r\n        if (node) {\r\n            if (!component && next.tag !== \"\") {\r\n                let length = children.length;\r\n                while (node.firstChild) {\r\n                    if (!length--) break;\r\n                    append(base, node.firstChild);\r\n                }\r\n            }\r\n            replace(parent, base, node);\r\n            if (!component) emitRemove(node);\r\n        } else {\r\n            append(parent, base);\r\n        }\r\n        isCreate = true;\r\n        next.emit(\"create\", base);\r\n    }\r\n    if (component) {\r\n        component.props = next.props;\r\n        component.context = context;\r\n        if (deep && component.prevent) {\r\n            return base;\r\n        }\r\n        return component.render(parent, base);\r\n    } else if (!next.tag) {\r\n        if (prev.props.children[0] !== next.props.children[0]) {\r\n            base.textContent = String(next.props.children[0]);\r\n        }\r\n    } else {\r\n        if (\r\n            isCreate ||\r\n            next.emit(\"update\", base, prev.props, next.props) !== false\r\n        ) {\r\n            diffProps(\r\n                base,\r\n                next.tag === prev.tag ? prev.props : {},\r\n                next.props,\r\n                isSvg\r\n            );\r\n            deep++;\r\n            let nextParent = next.props[attachShadow] ? root(base) : base,\r\n                childNodes = Array.from(nextParent.childNodes),\r\n                length = Math.max(childNodes.length, children.length);\r\n            for (let i = 0; i < length; i++) {\r\n                if (children[i]) {\r\n                    diff(\r\n                        nextParent,\r\n                        childNodes[i],\r\n                        children[i],\r\n                        context,\r\n                        isSvg,\r\n                        deep\r\n                    );\r\n                } else {\r\n                    if (childNodes[i]) {\r\n                        emitRemove(childNodes[i]);\r\n                        remove(nextParent, childNodes[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    base[MASTER] = {\r\n        prev: next,\r\n        components\r\n    };\r\n\r\n    next.emit(isCreate ? \"created\" : \"updated\", base);\r\n\r\n    return base;\r\n}\r\n/**\r\n * Update or delete the attributes and events of a node\r\n * @param {HTMLElement} node - Node to assign changes\r\n * @param {Object} prev - Previous status of attributes\r\n * @param {Object} next - next status of attributes\r\n * @param {Boolean} [isSvg] - If it belongs to svg tree\r\n */\r\nexport function diffProps(node, prev, next, isSvg) {\r\n    let prevKeys = Object.keys(prev),\r\n        nextKeys = Object.keys(next).filter(\r\n            key => prevKeys.indexOf(key) === -1\r\n        ),\r\n        keys = prevKeys.concat(nextKeys);\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (IGNORE.indexOf(prop) > -1 || prev[prop] === next[prop]) continue;\r\n        if (attachShadow === prop && attachShadow in node) {\r\n            node.attachShadow({ mode: next[prop] ? \"open\" : \"closed\" });\r\n        }\r\n        let isFnPrev = typeof prev[prop] === \"function\",\r\n            isFnNext = typeof next[prop] === \"function\";\r\n        if (isFnPrev || isFnNext) {\r\n            if (!isFnNext && isFnPrev) {\r\n                node.removeEventListener(prop, node[LISTENER][prop][0]);\r\n            }\r\n            if (isFnNext) {\r\n                if (!isFnPrev) {\r\n                    node[LISTENER] = node[LISTENER] || {};\r\n                    if (!node[LISTENER][prop]) {\r\n                        node[LISTENER][prop] = [\r\n                            event => {\r\n                                node[LISTENER][prop][1](event);\r\n                            }\r\n                        ];\r\n                    }\r\n                    node.addEventListener(prop, node[LISTENER][prop][0]);\r\n                }\r\n                node[LISTENER][prop][1] = next[prop];\r\n            }\r\n        } else if (prop in next) {\r\n            if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                if (prop === \"style\") {\r\n                    if (typeof next[prop] === \"object\") {\r\n                        let prevStyle = prev[prop] || {},\r\n                            nextStyle = next[prop];\r\n                        for (let prop in nextStyle) {\r\n                            if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                if (prop[0] === \"-\") {\r\n                                    node.setProperty(prop, nextStyle[prop]);\r\n                                } else {\r\n                                    node.style[prop] = nextStyle[prop];\r\n                                }\r\n                            }\r\n                        }\r\n                        // next[prop] = { ...prevStyle, ...nextStyle };\r\n                    } else {\r\n                        node.style.cssText = next[prop];\r\n                    }\r\n                } else {\r\n                    node[prop] = next[prop];\r\n                }\r\n            } else {\r\n                isSvg\r\n                    ? node.setAttributeNS(null, prop, next[prop])\r\n                    : node.setAttribute(prop, next[prop]);\r\n            }\r\n        } else {\r\n            node.removeAttribute(prop);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Issues the deletion of node and its children\r\n * @param {HTMLElement} base\r\n */\r\nexport function emitRemove(base) {\r\n    let { prev = new VDom() } = getMaster(base),\r\n        children = base.childNodes;\r\n    base[REMOVE] = true;\r\n    prev.emit(\"remove\", base);\r\n    for (let i = 0; i < children.length; i++) {\r\n        emitRemove(children[i]);\r\n    }\r\n    prev.emit(\"removed\", base);\r\n}\r\n"],"names":["VDom","tag","props","children","this","Object","h","concat","merge","let","i","length","child","Array","isArray","push","isVDom","value","root","parent","shadowRoot","remove","useShadowRoot","removeChild","append","appendChild","clone","emit","prop","prevent","ref","args","attachShadow","options","delay","MASTER","REMOVE","LISTENER","IGNORE","render","next","context","isSvg","diff","getMaster","base","Component","state","deep","key","components","setTimeout","node","currentKey","currentComponents","component","isCreate","addContext","prev","static","document","createElementNS","createElement","createTextNode","create","firstChild","newChild","oldChild","replaceChild","replace","emitRemove","prevKeys","keys","nextKeys","filter","indexOf","mode","isFnPrev","isFnNext","removeEventListener","event","addEventListener","prevStyle","nextStyle","setProperty","style","cssText","setAttributeNS","setAttribute","removeAttribute","diffProps","nextParent","childNodes","from","Math","max","textContent","String"],"mappings":"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"}