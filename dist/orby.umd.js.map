{"version":3,"file":"orby.umd.js","sources":["../src/vdom.js","../src/dom.js","../src/diff.js"],"sourcesContent":["export class VDom {\r\n    /**\r\n     *\r\n     * @param {Function|String} tag - Node component or label\r\n     * @param {Object} props - Properties of the label\r\n     * @param {Array} children - Children assigned to the node\r\n     */\r\n    constructor(tag, props = {}, children = []) {\r\n        this.tag = tag;\r\n        this.props = {\r\n            ...props,\r\n            children\r\n        };\r\n    }\r\n    /**\r\n     * Clone the current node by keeping props and children by default\r\n     * @param {Function|String} tag -  Node component or label\r\n     * @param {*} props - Properties of the label\r\n     * @param {*} children - Children assigned to the node\r\n     */\r\n    clone(tag = this.tag, props = this.props, children = this.props.children) {\r\n        return new VDom(tag, props, children);\r\n    }\r\n}\r\n/**\r\n * Prepare the virtual node\r\n * @param {Function|String} tag\r\n * @param {Object} props\r\n * @param  {...any} children\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag || \"\", props, concat(children));\r\n}\r\n/**\r\n * Clean existing values in virtual-dom tree\r\n * @param {*} children\r\n * @param {*} merge\r\n */\r\nexport function concat(children, next = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let value = children[i];\r\n        Array.isArray(value) ? concat(value, next) : next.push(value);\r\n    }\r\n    return next;\r\n}\r\n","export function create(tag, isSvg) {\r\n    if (tag) {\r\n        return isSvg\r\n            ? document.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n            : document.createElement(tag);\r\n    } else {\r\n        return document.createTextNode(\"\");\r\n    }\r\n}\r\n\r\nexport function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    parent.removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    parent.appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    parent.replaceChild(newChild, oldChild);\r\n}\r\n","import { VDom } from \"./vdom\";\r\nimport { create, remove, append, replace, root } from \"./dom\";\r\nexport { h } from \"./vdom\";\r\n\r\nexport let options = {\r\n    delay: 1\r\n};\r\n\r\nexport let COMPONENTS = \"__components__\";\r\n/**\r\n * Master is the mark to store the previous state\r\n * and if the node is controlled by one or more components\r\n */\r\nexport let PREVIOUS = \"__previous__\";\r\n/**\r\n * Each time a component is removed from the dom,\r\n * the property is marked as true\r\n */\r\nexport let REMOVE = \"__remove__\";\r\n\r\nexport let LISTENERS = \"__listeners__\";\r\n\r\n/**\r\n * Special properties of virtual dom,\r\n * these are ignored from the diffProps process,\r\n * since it is part of the component's life cycle\r\n */\r\n\r\nexport let IGNORE = /^(context|state|children|(create|update|remove)(d){0,1}|xmlns)$/;\r\n/**\r\n * It allows to print the status of virtual dom on the planned configuration\r\n * @param {VDom} next - the next state of the node\r\n * @param {HTMLElement} parent - the container of the node\r\n * @param {HTMLElement} [child]  - the ancestor of the node\r\n * @param {Object} [context] - the context of the node\r\n * @param {boolean} [isSvg] - check if the node belongs to a svg unit, to control it as such\r\n * @returns {HTMLElement} - The current node\r\n */\r\nexport function render(next, parent, child, context, isSvg) {\r\n    return diff(root(parent), child, next, context, isSvg);\r\n}\r\n\r\nexport function defer(handler) {\r\n    setTimeout(handler, options.delay);\r\n}\r\n\r\nexport function emit(vdom, prop, ...args) {\r\n    if (vdom.prevent) return;\r\n    if (prop === \"remove\") vdom.prevent = true;\r\n    if (vdom.props[prop]) vdom.props[prop](...args);\r\n}\r\n\r\nlet CURRENT_COMPONENT;\r\nlet CURRENT_KEY_STATE;\r\n\r\nexport function useState(initialState) {\r\n    let key = CURRENT_KEY_STATE++,\r\n        use = CURRENT_COMPONENT;\r\n    if (!(key in use.states)) {\r\n        use.states.push(\r\n            typeof initialState === \"function\" ? initialState() : initialState\r\n        );\r\n    }\r\n    return [\r\n        use.states[key],\r\n        nextState => {\r\n            use.states[key] = nextState;\r\n            if (use.prevent) return;\r\n            defer(() => {\r\n                use.render();\r\n                use.prevent = false;\r\n            });\r\n            use.prevent = true;\r\n        },\r\n        () => use.states[key]\r\n    ];\r\n}\r\n\r\nexport function useEffect(handler) {\r\n    CURRENT_COMPONENT.effects[0].push(handler);\r\n}\r\n/**\r\n *\r\n * @param {Function} component  - Function that controls the node\r\n * @param {*} [currentState] - The initial state of the component\r\n * @param {Boolean} [isSvg] - Create components for a group of svg\r\n * @return {HTMLElement} - Returns the current component node\r\n */\r\nexport class Component {\r\n    constructor(tag, isSvg, deep, currentKey, currentComponents) {\r\n        this.base;\r\n        this.parent;\r\n        this.tag = tag;\r\n        this.props = {};\r\n        this.states = [];\r\n        this.effects = [];\r\n        this.context = {};\r\n        this.prevent = false;\r\n        this.render = () => {\r\n            //if (this.prevent) return this.base;\r\n            if (this.base[REMOVE]) return;\r\n\r\n            CURRENT_KEY_STATE = 0;\r\n            CURRENT_COMPONENT = this;\r\n\r\n            this.effects = [[], []];\r\n\r\n            let nextStateRender = tag(this.props, this.context);\r\n\r\n            CURRENT_COMPONENT = false;\r\n\r\n            this.base = diff(\r\n                this.parent,\r\n                this.base,\r\n                nextStateRender,\r\n                this.context,\r\n                isSvg,\r\n                deep + 1,\r\n                currentKey + 1,\r\n                currentComponents\r\n            );\r\n\r\n            this.effects[1] = this.effects[0].map(handler => handler());\r\n\r\n            return this.base;\r\n        };\r\n    }\r\n}\r\n/**\r\n * It allows to print the status of virtual dom on the planned configuration\r\n * @param {HTMLElement} parent - the container of the node\r\n * @param {HTMLElement} [node]  - the ancestor of the node\r\n * @param {VDom} next - the next state of the node\r\n * @param {Object} [context] - the context of the node\r\n * @param {boolean} [isSvg] - check if the node belongs to a svg unit, to control it as such\r\n * @param {number} [deep] - this is a depth marker used to generate an index to store the state of the component\r\n * @param {number} [currentKey] - when generating a component of high order, it has a currentKey\r\n *                                other than 0, this allows to point to the state of the component correctly\r\n * @param {object} [currentComponents] - the functional components are stored in an object created by the first component\r\n * @returns {HTMLElement} - The current node\r\n */\r\n\r\nexport function diff(\r\n    parent,\r\n    node,\r\n    next,\r\n    context = {},\r\n    isSvg,\r\n    deep = 0,\r\n    currentKey = 0,\r\n    currentComponents = {}\r\n) {\r\n    let prev = (node && node[PREVIOUS]) || new VDom(),\r\n        components = (node && node[COMPONENTS]) || currentComponents,\r\n        base = node,\r\n        isCreate,\r\n        component,\r\n        withUpdate = true;\r\n\r\n    if (prev === next) return base;\r\n\r\n    if (!(next instanceof VDom)) {\r\n        next = new VDom(\"\", {}, next);\r\n    }\r\n\r\n    let children = next.props.children,\r\n        addContext = next.props.context;\r\n\r\n    context = addContext ? { ...context, ...addContext } : context;\r\n\r\n    isSvg = next.tag === \"svg\" || isSvg;\r\n\r\n    if (components[currentKey] && components[currentKey].tag !== next.tag) {\r\n        removeComponent(components[currentKey]);\r\n        delete components[currentKey];\r\n    }\r\n\r\n    if (typeof next.tag === \"function\") {\r\n        if ((components[currentKey] || {}).tag !== next.tag) {\r\n            components[currentKey] = new Component(\r\n                next.tag,\r\n                isSvg,\r\n                deep,\r\n                currentKey,\r\n                components\r\n            );\r\n        }\r\n        component = components[currentKey];\r\n        next = next.clone(prev.tag || \"\");\r\n    }\r\n\r\n    if (prev.tag !== next.tag) {\r\n        base = create(next.tag, isSvg);\r\n        if (node) {\r\n            if (!component && next.tag) {\r\n                let length = children.length;\r\n                while (node.firstChild) {\r\n                    if (!length--) break;\r\n                    append(base, node.firstChild);\r\n                }\r\n            }\r\n            replace(parent, base, node);\r\n            if (!component && prev.tag) {\r\n                recollectNodeTree(node);\r\n            }\r\n        } else {\r\n            append(parent, base);\r\n        }\r\n        isCreate = true;\r\n        emit(next, \"create\", base);\r\n    }\r\n\r\n    if (component) {\r\n        component.base = base;\r\n        component.parent = parent;\r\n        component.props = next.props;\r\n        component.context = context;\r\n\r\n        //if (deep && component.prevent) {\r\n        if (component.prevent) {\r\n            return component.base;\r\n        }\r\n\r\n        return component.render();\r\n    } else if (next.tag) {\r\n        withUpdate =\r\n            emit(next, \"update\", base, prev.props, next.props) !== false;\r\n        if (isCreate || withUpdate) {\r\n            diffProps(\r\n                base,\r\n                prev.tag === next.tag ? prev.props : {},\r\n                next.props,\r\n                isSvg\r\n            );\r\n            let nextParent = next.props.scoped ? root(base) : base,\r\n                childNodes = nextParent.childNodes,\r\n                move = 0,\r\n                length = Math.max(children.length, childNodes.length);\r\n            for (let i = 0; i < length; i++) {\r\n                let childI = i - move;\r\n                if (i in children) {\r\n                    diff(\r\n                        nextParent,\r\n                        childNodes[childI],\r\n                        children[i],\r\n                        context,\r\n                        isSvg\r\n                    );\r\n                } else {\r\n                    recollectNodeTree(childNodes[childI]);\r\n                    remove(nextParent, childNodes[childI]);\r\n                    move++;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (prev.props.children !== next.props.children) {\r\n            base.textContent = next.props.children;\r\n        }\r\n    }\r\n\r\n    base[PREVIOUS] = withUpdate ? next : prev;\r\n    base[COMPONENTS] = components;\r\n\r\n    emit(next, isCreate ? \"created\" : \"updated\", base);\r\n\r\n    return base;\r\n}\r\n/**\r\n * Update or delete the attributes and events of a node\r\n * @param {HTMLElement} node - Node to assign changes\r\n * @param {Object} prev - Previous status of attributes\r\n * @param {Object} next - next status of attributes\r\n * @param {Boolean} [isSvg] - If it belongs to svg tree\r\n */\r\nexport function diffProps(node, prev, next, isSvg) {\r\n    let prevKeys = Object.keys(prev),\r\n        nextKeys = Object.keys(next),\r\n        keys = prevKeys.concat(nextKeys),\r\n        define = {};\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (define[prop] || prev[prop] === next[prop] || IGNORE.test(prop))\r\n            continue;\r\n\r\n        define[prop] = true;\r\n\r\n        if (\"scoped\" === prop && \"attachShadow\" in node) {\r\n            node.attachShadow({ mode: next[prop] ? \"open\" : \"closed\" });\r\n            continue;\r\n        }\r\n\r\n        let isFnPrev = typeof prev[prop] === \"function\",\r\n            isFnNext = typeof next[prop] === \"function\";\r\n\r\n        if (isFnPrev || isFnNext) {\r\n            if (!isFnNext && isFnPrev) {\r\n                node.removeEventListener(prop, node[LISTENERS][prop][0]);\r\n            }\r\n            if (isFnNext) {\r\n                if (!isFnPrev) {\r\n                    node[LISTENERS] = node[LISTENERS] || {};\r\n                    if (!node[LISTENERS][prop]) {\r\n                        node[LISTENERS][prop] = [\r\n                            event => {\r\n                                node[LISTENERS][prop][1](event);\r\n                            }\r\n                        ];\r\n                    }\r\n                    node.addEventListener(prop, node[LISTENERS][prop][0]);\r\n                }\r\n                node[LISTENERS][prop][1] = next[prop];\r\n            }\r\n        } else if (prop in next) {\r\n            if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                if (prop === \"style\") {\r\n                    if (typeof next[prop] === \"object\") {\r\n                        let prevStyle = prev[prop] || {},\r\n                            nextStyle = next[prop];\r\n                        for (let prop in nextStyle) {\r\n                            if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                if (prop[0] === \"-\") {\r\n                                    node.style.setProperty(\r\n                                        prop,\r\n                                        nextStyle[prop]\r\n                                    );\r\n                                } else {\r\n                                    node.style[prop] = nextStyle[prop];\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        node.style.cssText = next[prop];\r\n                    }\r\n                } else {\r\n                    node[prop] = next[prop];\r\n                }\r\n            } else {\r\n                isSvg\r\n                    ? node.setAttributeNS(null, prop, next[prop])\r\n                    : node.setAttribute(prop, next[prop]);\r\n            }\r\n        } else {\r\n            node.removeAttribute(prop);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Issues the deletion of node and its children\r\n * @param {HTMLElement} base\r\n */\r\nexport function recollectNodeTree(node) {\r\n    let prev = node[PREVIOUS],\r\n        components = node[COMPONENTS],\r\n        children = node.childNodes;\r\n\r\n    if (!prev) return;\r\n\r\n    node[REMOVE] = true;\r\n\r\n    for (let key in components) {\r\n        removeComponent(components[key]);\r\n    }\r\n\r\n    emit(prev, \"remove\", node);\r\n\r\n    for (let i = 0; i < children.length; i++) {\r\n        recollectNodeTree(children[i]);\r\n    }\r\n\r\n    emit(prev, \"removed\", node);\r\n}\r\n\r\nexport function removeComponent(component) {\r\n    let effectsRemove = component.effects[1];\r\n    for (let i = 0; i < effectsRemove.length; i++) {\r\n        if (effectsRemove[i]) effectsRemove[i](component);\r\n    }\r\n}\r\n"],"names":["VDom","tag","props","children","this","Object","root","parent","shadowRoot","remove","child","removeChild","append","appendChild","clone","CURRENT_COMPONENT","CURRENT_KEY_STATE","options","delay","COMPONENTS","PREVIOUS","REMOVE","LISTENERS","IGNORE","emit","vdom","prop","prevent","ref","args","Component","isSvg","deep","currentKey","currentComponents","states","effects","context","render","base","let","nextStateRender","diff","map","handler","node","next","isCreate","component","prev","components","withUpdate","addContext","removeComponent","document","createElementNS","createElement","createTextNode","create","length","firstChild","newChild","oldChild","replaceChild","replace","recollectNodeTree","prevKeys","keys","nextKeys","concat","define","i","test","attachShadow","mode","isFnPrev","isFnNext","removeEventListener","event","addEventListener","prevStyle","nextStyle","style","setProperty","cssText","setAttributeNS","setAttribute","removeAttribute","diffProps","nextParent","scoped","childNodes","move","Math","max","childI","textContent","key","effectsRemove","value","Array","isArray","push","initialState","use","nextState","setTimeout"],"mappings":"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"}